# ソースコードの詳細設計書

---

## **処理の流れ**

### **1. Excelファイルの読み込み**
- **目的**:
  - 指定されたExcelファイルから、すべてのシートを読み込む。
  - 各シートのデータを個別に処理するため、シート名をキー、データフレームを値とする辞書形式で保持。
  
- **処理手順**:
  1. Pythonライブラリ`pandas`の`read_excel`関数を使用。
  2. 引数`sheet_name=None`を指定して、Excel内のすべてのシートを辞書形式で読み込む。
  3. この辞書を返し、後続処理で利用。

- **生成されるデータ構造**:
  - 以下のような辞書が作成される：
    ```python
    {
      "Sheet1": pandas.DataFrame,
      "Sheet2": pandas.DataFrame,
      ...
    }
    ```

---

### **2. シートごとのデータ処理**
- **目的**:
  - 各シートのデータを行ごとに処理し、HCL形式の階層構造を構築する。

- **処理手順**:
  1. 読み込んだシートごとにループ処理を開始。
  2. 各シートのデータフレームの行を一つずつ処理。
     - `generate_tfvars_flag`が`False`の行は無視する。
  3. 各行について、以下のデータを取得：
     - `resource`（リソース名）
     - `arguments`（パラメータ名、ドット区切りの形式）
     - `value`（パラメータ値）
  4. `arguments`をドットで分割してキーリストを生成。
     - 例: `root_block_device.0.volume_size` → `["root_block_device", "0", "volume_size"]`
  5. キーリストと値をもとに、リソース内のネストされた構造を再帰的に構築。
     - リスト（`[]`）や辞書（`{}`）を動的に初期化して追加。

- **処理の結果**:
  - 各リソースが以下のような辞書形式で構築される：
    ```python
    {
      "aws_instance": {
        "ami": "ami-005e54dee72cc1d00",
        "root_block_device": [
          {
            "volume_size": 20,
            "volume_type": "gp3"
          },
          {
            "volume_size": 40,
            "volume_type": "gp4"
          }
        ],
        "tags": {
          "Name": "ec2",
          "Environment": "dev"
        }
      }
    }
    ```

---

### **3. リソースの統合**
- **目的**:
  - 各シートごとに構築されたリソースをシート名ごとにまとめ、さらにブック全体を統合する。

- **処理手順**:
  1. シート名をキー、対応するリソース辞書を値として保持。
  2. 各シートのリソースを一つの辞書に統合。
  3. 最上位階層にブック名を追加し、すべてのシートをブック名の下に配置。

- **生成されるデータ構造**:
  - 以下のようにブック名、シート名、リソース名の3層構造が構築される：
    ```python
    {
      "ec2": {
        "Sheet1": {
          "aws_instance": {
            "ami": "ami-005e54dee72cc1d00",
            "root_block_device": [
              {
                "volume_size": 20,
                "volume_type": "gp3"
              },
              {
                "volume_size": 40,
                "volume_type": "gp4"
              }
            ],
            "tags": {
              "Name": "ec2",
              "Environment": "dev"
            }
          }
        },
        "Sheet2": {
          ...
        }
      }
    }
    ```

---

### **4. HCL形式への変換**
- **目的**:
  - 構築した辞書構造をHCL形式の文字列に変換する。

- **処理手順**:
  1. 再帰的に辞書やリストを処理し、HCL形式の文字列を生成。
  2. 値がリストの場合：
     - リスト内が辞書の場合、HCL形式で整形。
     - それ以外のリストはJSON形式で出力。
  3. 値が辞書の場合：
     - 辞書内のキーと値を再帰的に処理。
  4. 単純な値の場合：
     - `json.dumps`を使用して文字列化。

- **生成される文字列**:
  - 以下のようなHCL形式で出力：
    ```hcl
    ec2 = {
      Sheet1 = {
        aws_instance = {
          ami = "ami-005e54dee72cc1d00"
          root_block_device = [
            {
              volume_size = 20
              volume_type = "gp3"
            },
            {
              volume_size = 40
              volume_type = "gp4"
            }
          ]
          tags = {
            Name = "ec2"
            Environment = "dev"
          }
        }
      }
    }
    ```

---

### **5. HCLファイルの生成**
- **目的**:
  - 生成したHCL形式の文字列を`.tfvars`ファイルとして保存する。

- **処理手順**:
  1. 指定した出力フォルダを確認し、存在しない場合は作成。
  2. ファイルにHCL形式の文字列を書き込む。
  3. 出力ファイルのパスを返す。

- **生成されるファイル**:
  - ファイル名：`output.tfvars`
  - 保存場所：`./output_tfvars/`

---

### **処理全体のフロー**
以下は処理の全体フローです：

1. **Excelファイル読み込み**:
   - すべてのシートを辞書形式で取得。
2. **シートごとの処理**:
   - 各行を解析し、リソース名をキーとしたネストされた構造を構築。
3. **リソース統合**:
   - 各シートを統合し、さらにブック全体をまとめる。
4. **HCL形式変換**:
   - 辞書構造を再帰的に処理し、HCL形式の文字列を生成。
5. **ファイル出力**:
   - `.tfvars`形式でHCLを保存。

---
